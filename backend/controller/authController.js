import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import User from "../models/User.js";

// same helper as before
const buildSocialLinksFromBody = (body) => {
  const social = {};
  Object.keys(body || {}).forEach((key) => {
    const match = key.match(/^socialLinks\[(.+)\]$/);
    if (match) {
      social[match[1]] = body[key];
    }
  });
  if (typeof body.socialLinks === "object") {
    Object.assign(social, body.socialLinks);
  }
  return social;
};

const DEFAULT_AVATAR = "https://res.cloudinary.com/dw8ck8ubc/image/upload/v1764570837/userLogo_ror22k.png";


const makeGeneratedEmail = (uniqueId, domain = "gmail.com") => {
  return `${String("user" + uniqueId).trim().toLowerCase()}@${domain}`;
};


// REGISTER USER (self-registration)
export const registerUser = async (req, res) => {
  try {
    const {
      fullName,
      penName,
      email,
      password,
      confirmPassword,
      bio,
      phone,
      tagline,
      profession,
      location,
    } = req.body;

    const socialLinks = buildSocialLinksFromBody(req.body);

    // avatar from upload if present
const avatarUrl = req.file
  ? req.file.path    // âœ” Cloudinary URL automatically provided
  : DEFAULT_AVATAR;


    if (!fullName) {
      return res.status(400).json({
        message: "fullName is required",
      });
    }

    // If password provided, confirm it; if not provided, we'll use uniqueId as password later
    if (password && confirmPassword && password !== confirmPassword) {
      return res.status(400).json({ message: "Passwords do not match" });
    }

    // If email provided, ensure unique
    if (email) {
      const existingEmailUser = await User.findOne({ email });
      if (existingEmailUser) {
        return res.status(400).json({ message: "Email already in use" });
      }
    }

    // Create user instance first to get uniqueId generated by schema
    const tempUser = new User({
      fullName,
      penName,
      email: email || undefined,
      bio: bio || "",
      phone: phone || "",
      tagline: tagline || "",
      profession: profession || "",
      location: location || "",
      avatar: avatarUrl,
      socialLinks,
      role: "user",
    });

    // Decide password: if frontend sent password -> use it, else use uniqueId
    const plainPassword = password && password.length ? password : tempUser.uniqueId;
    const hashedPassword = await bcrypt.hash(plainPassword, 10);
    tempUser.password = hashedPassword;

    await tempUser.save();

    res.status(201).json({
      message: "User registered successfully",
      userId: tempUser._id,
      uniqueId: tempUser.uniqueId,
      // Inform frontend if password was auto-generated
      passwordGenerated: !(password && password.length),
    });

  } catch (err) {
    console.error("Register error:", err);
    res.status(500).json({
      message: "Server error during registration",
      error: err.message,
    });
  }
};


export const createUserByAdmin = async (req, res) => {
  try {
    const {
      fullName,
      penName,
      email: rawEmail,
      bio,
      phone,
      tagline,
      profession,
      location,
      role
    } = req.body;

    if (!fullName) {
      return res.status(400).json({ message: "fullName is required" });
    }

    // ğŸ‘‡ SAME CLOUDINARY LOGIC AS REGISTER USER
const avatarUrl = req.file
  ? req.file.path    // âœ” Cloudinary URL automatically provided
  : DEFAULT_AVATAR;


    const newUser = new User({
      fullName,
      penName,
      bio: bio || "",
      phone: phone || "",
      tagline: tagline || "",
      profession: profession || "",
      location: location || "",
      avatar: avatarUrl,   // ğŸ‘ˆ CLOUDINARY URL SAVING
      socialLinks: {},
      role: role === "admin" ? "admin" : "user",
    });

    const emailProvided = rawEmail && String(rawEmail).trim().length > 0;
    const desiredEmail = emailProvided
      ? String(rawEmail).trim().toLowerCase()
      : makeGeneratedEmail(newUser.uniqueId, "gmail.com");

    if (emailProvided) {
      const exists = await User.findOne({ email: desiredEmail });
      if (exists) return res.status(400).json({ message: "Email already in use" });
      newUser.email = desiredEmail;
    } else {
      const collision = await User.findOne({ email: desiredEmail });
      if (collision) {
        newUser.email = `${newUser.uniqueId}_${Math.floor(Math.random() * 9000 + 1000)}@gmail.com`;
      } else {
        newUser.email = desiredEmail;
      }
    }

    const plainPassword = newUser.uniqueId;
    newUser.password = await bcrypt.hash(plainPassword, 10);

    await newUser.save();

    return res.status(201).json({
      message: "User created by admin",
      userId: newUser._id,
      uniqueId: newUser.uniqueId,
      email: newUser.email,
      avatar: newUser.avatar,  // ğŸ‘ˆ OPTIONAL RESPONSE
    });

  } catch (err) {
    console.error("Admin create user error:", err);
    return res.status(500).json({ message: "Server error", error: err.message });
  }
};


export const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: "User not found" });

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(400).json({ message: "Invalid credentials" });

    const token = jwt.sign(
      { userId: user._id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );

    // decide cookie name
    const cookieName = user.role === "admin" ? "adminToken" : "userToken";

    // set cookie using shared options
    res.cookie(cookieName, token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: process.env.NODE_ENV === "production" ? "none" : "lax",
      maxAge: 7 * 24 * 60 * 60 * 1000,
      path: "/",
    });

    // clear the other role cookie to avoid stale cookie
    if (cookieName === "adminToken") res.clearCookie("userToken", { path: "/" });
    else res.clearCookie("adminToken", { path: "/" });

    res.status(200).json({
      message: "Login successful",
      user: {
        id: user._id,
        fullName: user.fullName,
        penName: user.penName,
        email: user.email,
        role: user.role,
        phone: user.phone,
        bio: user.bio,
        tagline: user.tagline,
        profession: user.profession,
        location: user.location,
        avatar: user.avatar,
        uniqueId: user.uniqueId,
        socialLinks: user.socialLinks,
      },
      token, // frontend can use this if it needs client-side access
    });
  } catch (err) {
    console.error("âŒ Login error =>", err);
    res.status(500).json({ message: "Server error" });
  }
};


export const logoutUser = (req, res) => {
  const cookieOptions = {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: process.env.NODE_ENV === "production" ? "none" : "lax",
    path: "/",
  };

  res.clearCookie("userToken", cookieOptions);
  res.clearCookie("adminToken", cookieOptions);
  res.json({ success: true, message: "Logged out successfully" });
};


export const getLoggedInUser = (req, res) => {
  if (!req.user) return res.json({ success: false });

  res.json({
    success: true,
    user: req.user,
  });
};
